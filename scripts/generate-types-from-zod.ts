#!/usr/bin/env node
/**
 * Generate TypeScript types from Zod schemas
 * This script creates a centralized type registry from all Zod schemas in the codebase
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');
const ts = require('typescript');

// Configuration
const ROOT_DIR = path.join(__dirname, '..');
const OUTPUT_DIR = path.join(ROOT_DIR, 'packages/shared/src/generated');
const SEARCH_PATTERNS = [
  'packages/**/src/**/*.ts',
  '!packages/**/src/**/*.test.ts',
  '!packages/**/src/**/*.spec.ts',
  '!packages/**/src/**/*.d.ts',
  '!**/node_modules/**',
  '!**/dist/**',
  '!**/generated/**',
];

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Find all TypeScript files that might contain Zod schemas
function findTypeScriptFiles() {
  const files = [];
  
  for (const pattern of SEARCH_PATTERNS) {
    if (!pattern.startsWith('!')) {
      const matches = glob.sync(pattern, { cwd: ROOT_DIR, absolute: true });
      files.push(...matches);
    }
  }
  
  // Filter out excluded patterns - check for node_modules, dist, generated, test files
  return files.filter(file => {
    const relativePath = path.relative(ROOT_DIR, file);
    return !relativePath.includes('node_modules') &&
           !relativePath.includes('/dist/') &&
           !relativePath.includes('/generated/') &&
           !file.endsWith('.test.ts') &&
           !file.endsWith('.spec.ts') &&
           !file.endsWith('.d.ts');
  });
}

// Schema information interface
class SchemaInfo {
  constructor(name, filePath, isExported, hasTypeExport) {
    this.name = name;
    this.filePath = filePath;
    this.isExported = isExported;
    this.hasTypeExport = hasTypeExport;
    this.packageName = this.extractPackageName(filePath);
  }

  extractPackageName(filePath) {
    const match = filePath.match(/packages\/([^/]+)\//);
    return match ? match[1] : 'unknown';
  }

  get typeName() {
    return this.name.replace(/Schema$/, '');
  }
}

// Extract Zod schema definitions from a TypeScript file
function extractZodSchemas(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  
  // Quick check if file imports zod
  if (!content.includes('from \'zod\'') && !content.includes('from "zod"')) {
    return [];
  }
  
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.Latest,
    true
  );
  
  const schemas = [];
  const exportedTypes = new Set();
  
  function visit(node) {
    // Track exported types
    if (ts.isTypeAliasDeclaration(node) && node.modifiers?.some(m => m.kind === ts.SyntaxKind.ExportKeyword)) {
      exportedTypes.add(node.name.text);
    }
    
    // Look for variable declarations that might be Zod schemas
    if (ts.isVariableStatement(node)) {
      const isExported = node.modifiers?.some(
        mod => mod.kind === ts.SyntaxKind.ExportKeyword
      ) || false;
      
      node.declarationList.declarations.forEach(declaration => {
        if (ts.isIdentifier(declaration.name) && declaration.initializer) {
          const name = declaration.name.text;
          const initText = declaration.initializer.getText(sourceFile);
          
          // Check if this looks like a Zod schema
          if (name.endsWith('Schema') && 
              (initText.includes('z.object') || 
               initText.includes('z.enum') || 
               initText.includes('z.union') ||
               initText.includes('z.array') ||
               initText.includes('z.discriminatedUnion') ||
               initText.includes('z.string') ||
               initText.includes('z.number') ||
               initText.includes('z.boolean'))) {
            
            const typeName = name.replace(/Schema$/, '');
            const hasTypeExport = exportedTypes.has(typeName);
            
            schemas.push(new SchemaInfo(name, filePath, isExported, hasTypeExport));
          }
        }
      });
    }
    
    ts.forEachChild(node, visit);
  }
  
  visit(sourceFile);
  return schemas;
}

// Generate the main types file
function generateTypesFile(schemas) {
  const exportedSchemas = schemas.filter(s => s.isExported);
  const groupedByPackage = {};
  
  exportedSchemas.forEach(schema => {
    if (!groupedByPackage[schema.packageName]) {
      groupedByPackage[schema.packageName] = [];
    }
    groupedByPackage[schema.packageName].push(schema);
  });
  
  let output = `/**
 * Auto-generated TypeScript type registry from Zod schemas
 * Generated on: ${new Date().toISOString()}
 * 
 * This file provides a centralized registry of all Zod schemas and their inferred types.
 * DO NOT EDIT THIS FILE DIRECTLY - Run 'npm run generate:types' to regenerate
 */

import { z } from 'zod';

`;

  // Group imports by package
  Object.entries(groupedByPackage).forEach(([packageName, packageSchemas]) => {
    const schemaNames = packageSchemas.map(s => s.name).join(', ');
    const relativePath = packageName === 'shared' ? '..' : `../../${packageName}/src`;
    
    output += `// Schemas from @primo-poker/${packageName}\n`;
    output += `import { ${schemaNames} } from '${relativePath}';\n\n`;
  });

  output += `/**
 * Generated type definitions from Zod schemas
 * These types are automatically inferred from their corresponding schemas
 */\n\n`;

  // Generate type definitions
  const allTypes = [];
  exportedSchemas.forEach(schema => {
    if (!schema.hasTypeExport) {
      const generatedTypeName = `Generated${schema.typeName}`;
      output += `export type ${generatedTypeName} = z.infer<typeof ${schema.name}>;\n`;
      allTypes.push({ name: schema.typeName, generatedName: generatedTypeName });
    }
  });

  // Add schema registry
  output += `\n/**
 * Schema Registry - All available Zod schemas organized by domain
 */
export const SchemaRegistry = {
`;

  Object.entries(groupedByPackage).forEach(([packageName, packageSchemas]) => {
    output += `  ${packageName}: {\n`;
    packageSchemas.forEach(schema => {
      output += `    ${schema.name},\n`;
    });
    output += `  },\n`;
  });

  output += `} as const;\n\n`;

  // Add type registry for generated types
  if (allTypes.length > 0) {
    output += `/**
 * Type Registry - Generated types that don't have explicit exports
 */
export interface GeneratedTypeRegistry {\n`;
    
    allTypes.forEach(({ name, generatedName }) => {
      output += `  ${name}: ${generatedName};\n`;
    });
    
    output += `}\n`;
  }

  return output;
}

// Generate a validation utilities file
function generateValidationUtils(schemas) {
  const exportedSchemas = schemas.filter(s => s.isExported);
  
  let output = `/**
 * Auto-generated validation utilities for Zod schemas
 * Generated on: ${new Date().toISOString()}
 * 
 * DO NOT EDIT THIS FILE DIRECTLY - Run 'npm run generate:types' to regenerate
 */

import { z } from 'zod';
import { SchemaRegistry } from './types';

/**
 * Type-safe validation helper
 * Validates unknown data against a schema and returns typed result
 */
export function validateWithSchema<T extends keyof typeof SchemaRegistry, K extends keyof typeof SchemaRegistry[T]>(
  domain: T,
  schemaName: K,
  data: unknown
): z.infer<typeof SchemaRegistry[T][K]> {
  const schema = SchemaRegistry[domain][schemaName] as z.ZodSchema;
  return schema.parse(data);
}

/**
 * Safe validation helper
 * Returns a result object instead of throwing
 */
export function safeValidateWithSchema<T extends keyof typeof SchemaRegistry, K extends keyof typeof SchemaRegistry[T]>(
  domain: T,
  schemaName: K,
  data: unknown
): z.SafeParseReturnType<unknown, z.infer<typeof SchemaRegistry[T][K]>> {
  const schema = SchemaRegistry[domain][schemaName] as z.ZodSchema;
  return schema.safeParse(data);
}

/**
 * Batch validation helper
 * Validates multiple items against the same schema
 */
export function validateBatch<T extends keyof typeof SchemaRegistry, K extends keyof typeof SchemaRegistry[T]>(
  domain: T,
  schemaName: K,
  items: unknown[]
): z.infer<typeof SchemaRegistry[T][K]>[] {
  const schema = SchemaRegistry[domain][schemaName] as z.ZodSchema;
  return items.map(item => schema.parse(item));
}
`;

  return output;
}

// Main function
function main() {
  console.log('üîç Searching for TypeScript files...');
  const files = findTypeScriptFiles();
  console.log(`üìÅ Found ${files.length} TypeScript files to scan`);
  
  console.log('\nüîé Extracting Zod schemas...');
  const allSchemas = [];
  
  files.forEach(file => {
    const schemas = extractZodSchemas(file);
    if (schemas.length > 0) {
      const relativePath = path.relative(ROOT_DIR, file);
      console.log(`  Found ${schemas.length} schemas in ${relativePath}`);
      allSchemas.push(...schemas);
    }
  });
  
  const exportedSchemas = allSchemas.filter(s => s.isExported);
  console.log(`\nüìä Total schemas found: ${allSchemas.length}`);
  console.log(`üìä Exported schemas: ${exportedSchemas.length}`);
  
  if (exportedSchemas.length === 0) {
    console.log('‚ùå No exported Zod schemas found!');
    return;
  }
  
  console.log('\n‚úèÔ∏è  Generating type registry...');
  const typesContent = generateTypesFile(allSchemas);
  const typesPath = path.join(OUTPUT_DIR, 'types.ts');
  fs.writeFileSync(typesPath, typesContent);
  console.log(`‚úÖ Type registry written to: generated/types.ts`);
  
  console.log('\n‚úèÔ∏è  Generating validation utilities...');
  const validationContent = generateValidationUtils(allSchemas);
  const validationPath = path.join(OUTPUT_DIR, 'validation.ts');
  fs.writeFileSync(validationPath, validationContent);
  console.log(`‚úÖ Validation utilities written to: generated/validation.ts`);
  
  // Create index file for generated directory
  const indexContent = `/**
 * Auto-generated exports
 * DO NOT EDIT THIS FILE DIRECTLY
 */

export * from './types';
export * from './validation';
`;
  
  const indexPath = path.join(OUTPUT_DIR, 'index.ts');
  fs.writeFileSync(indexPath, indexContent);
  console.log(`‚úÖ Index file written to: generated/index.ts`);
  
  // Update the main shared package exports if needed
  const sharedIndexPath = path.join(ROOT_DIR, 'packages/shared/src/index.ts');
  const sharedIndexContent = fs.readFileSync(sharedIndexPath, 'utf-8');
  
  if (!sharedIndexContent.includes('./generated')) {
    const updatedContent = sharedIndexContent + '\n// Auto-generated types and utilities\nexport * from \'./generated\';\n';
    fs.writeFileSync(sharedIndexPath, updatedContent);
    console.log('‚úÖ Updated shared/src/index.ts with generated exports');
  }
  
  console.log('\nüéâ Type generation complete!');
  console.log('\nüìù Next steps:');
  console.log('  1. Run "npm install" to install dependencies');
  console.log('  2. Run "npm run build" to build the project with generated types');
  console.log('  3. Import types from "@primo-poker/shared/generated"');
}

// Run the script
try {
  main();
} catch (error) {
  console.error('‚ùå Error generating types:', error);
  process.exit(1);
}